name: Docker Image Cache Action
description: |
  This action pulls and caches container images
author: Telicent
branding:
  icon: 'download-cloud'
  color: 'purple'
inputs:
  images:
    required: true
    description: |
      Specifies one/more image references that should be pulled and cached
  restore-only:
    required: false
    default: "false"
    description: |
      Specifies whether the cache should only be restored
  temp-path:
    required: false
    default: ".images"
    description: |
      Specifies a temporary directory used for storing the Docker Image Tarballs
outputs:
  cache-key:
    value: ${{ steps.cache-key.outputs.key }}
    description: |
      The Docker Images cache key generated based upon hashing the provided image references
  cache-path:
    value: ${{ inputs.temp-path }}
    description: |
      The path associated with the cache entry generated by this action, this in combination with
      the cache-key output uniquely identifies the cache entry.

      See https://github.com/actions/cache/blob/main/README.md#cache-version for more context.
runs:
  using: "composite"
  steps:
    - name: Fail if attempting to cache Latest
      if: ${{ contains(inputs.images, ':latest')}}
      shell: bash
      run: |
        echo "::error title=${{ github.job }} - Can't Cache Latest::One/more images is a reference to a ':latest' tag which cannot be cached"
        exit 1

    - name: Generate Cache Key
      id: cache-key
      shell: bash
      run: |
        echo "key=docker-images-$(echo "${{ inputs.images }}" | openssl md5 | awk '{print $2}')" >> $GITHUB_OUTPUT

    - name: Make temporary directory
      shell: bash
      run: |
        mkdir -p "${{ inputs.temp-path }}"
        echo "${{ inputs.images }}" > "${{ inputs.temp-path}}/images"

    - name: Restore Cache Only
      if: ${{ inputs.restore-only == 'true' }}
      id: restore-only
      uses: actions/cache/restore@v4
      with:
        key: ${{ steps.cache-key.outputs.key }}
        path: ${{ inputs.temp-path }}

    - name: Image Cache
      if: ${{ inputs.restore-only != 'true' }}
      id: image-cache
      uses: actions/cache@v4
      with: 
        key: ${{ steps.cache-key.outputs.key }}
        path: ${{ inputs.temp-path }}

    - name: Pull Images if Needed (unless restore-only set)
      if: ${{ inputs.restore-only != 'true' && steps.image-cache.outputs.cache-hit != 'true' }}
      id: pull-images
      shell: bash
      run: |
        for IMAGE in $(cat "${{ inputs.temp-path }}/images"); do
          if [ -z "${IMAGE}" ]; then
            continue
          fi
          SANITISED=$(echo "${IMAGE}" | sed 's/[:/<>|*?\]/-/g' | tr -s '-')
          echo "Pulling Image ${IMAGE} and Saving to ${{ inputs.temp-path }}/${SANITISED}.tar"
          docker pull "${IMAGE}" && docker image save "${IMAGE}" --output "${{ inputs.temp-path }}/${SANITISED}.tar"
        done

        # List Image Tarballs for debugging
        ls -lh "${{ inputs.temp-path }}"

    - name: Load Docker Images if Needed
      if: ${{ inputs.restore-only == 'true' || steps.pull-images.outcome == 'skipped' }}
      shell: bash
      run: |
        for IMAGE in $(ls "${{ inputs.temp-path }}"); do
          FILE_EXT=${IMAGE##*.}
          if [ "${FILE_EXT}" != "tar" ]; then
            continue
          fi
          echo "Loading Docker image from Tarball ${IMAGE}"
          docker image load --input "${{inputs.temp-path}}/${IMAGE}"
        done

